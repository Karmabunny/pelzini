<?php
/*
Copyright 2015-2016 Karmabunny Pty Ltd

This file is a part of Pelzini, originally from SproutCMS.

Pelzini is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Pelzini is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Pelzini.  If not, see <http://www.gnu.org/licenses/>.
*/


/**
 * Class for doing database queries via PDO
 */
class PdoOutputter extends DatabaseOutputter
{
    /** Underlying PDO connection */
    protected $pdo = null;

    /** Whether a transaction is currently open */
    protected $in_transaction = false;

    /** Auto-increment ID generated by most recent INSERT query */
    protected $last_insert_id;

    /** Number of rows affected by most recent query */
    protected $affected_rows = 0;

    /**
     * Result sets which have been exhausted (i.e. already completely looped through).
     * Some DB layers allow reuse of result sets. PDO doesn't, so an exception is thrown if such an attempt is made.
     */
    protected $exhausted = [];


    /**
     * Sets up a new connection
     * @param string $dsn Data Source Name; see http://php.net/manual/en/pdo.construct.php
     *        Typically it should look like: {$type}:host={$host};dbname={$db};charset={$charset};port={$port}
     *        Apart from type, host and dbname, most of those are probably optional
     *        E.g. mysql:host=localhost;dbname=mydb;charset=utf8
     * @param string $username
     * @param string $password
     * @param array $options PDO options; see http://php.net/manual/en/pdo.construct.php
     */
    public function __construct($dsn, $username, $password, array $options = [])
    {
        $this->pdo = new PDO($dsn, $username, $password, $options);
        if (!$this->pdo) $this->pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    }


    /**
     * Checkes the connection was opened by the constructor
     */
    public function connect()
    {
        return ($this->pdo != false);
    }


    /**
     * Executes a PDO query
     *
     * For the return type 'pdo', a PDOStatement is returned. You need to close it using $res->closeCursor()
     *     once you're finished.
     * For the return type 'prep', a prepared (but not executed) PDOStatement is returned.
     *     This should be executed using the {@see Pdb::execute} method.
     * For the return type 'null', nothing is returned.
     * For the return type 'count', a count of rows is returned.
     * Additional return types are available; {@see Pdb::formatRs} for a full list.
     *
     * When working with datasets larger than about 50 rows, you may run out of ram when using
     * return types other than 'pdo', 'null', 'count' or 'val' because the other types all return the values as arrays
     *
     * @param string $query The query to execute. Prefix a table name with a tilde (~) to automatically include the
     *        table prefix, e.g. ~pages will be converted to sprout_pages
     * @param array $params Parameters to bind to the query
     * @param string $return_type 'pdo', 'prep', 'count', 'null', or a format type {@see Pdb::formatRs}
     * @return PDOStatement For type 'pdo' and 'prep'
     * @return int For type 'count'
     * @return null For type 'null'
     * @return mixed For all other types; see {@see Pdb::formatRs}
     * @throws InvalidArgumentException If $query isn't a string
     * @throws InvalidArgumentException If the return type isn't valid
     * @throws QueryException If the query execution or formatting failed
     */
    public function query($query, array $params = [], $return_type = 'pdo')
    {
        if (!is_string($query)) {
            if ($query instanceof PDOStatement) {
                $err = '$query must be a string. You must call Pdb::execute on a PDOStatement';
                throw new InvalidArgumentException($err);
            }
            throw new InvalidArgumentException('$query must be a string');
        }

        static $types = [
            'pdo', 'prep', 'null', 'count', 'arr', 'arr-num', 'row', 'row-num', 'map', 'map-arr', 'val', 'col'
        ];

        $return_type = strtolower($return_type);
        if (!in_array($return_type, $types)) {
            $err = 'Invalid $return_type; see documentation';
            throw new InvalidArgumentException($err);
        }

        if ($return_type === 'prep' and count($params) !== 0) {
            $err = 'You cannot provide parameters when preparing statements';
            throw new InvalidArgumentException($err);
        }

        $st = $this->pdo->prepare($query);
        if ($return_type === 'prep') {
            return $st;
        }
        $st->execute($params);
        $res = $st;

        // Save the insert ID
        if (stripos($query, 'INSERT') === 0) {
            $this->last_insert_id = $this->pdo->lastInsertId();
        }

        if ($return_type == 'pdo') {
            $res->setFetchMode(PDO::FETCH_ASSOC);
            return $res;
        } else if ($return_type == 'null') {
            $res->closeCursor();
            return null;
        } else if ($return_type == 'count') {
            $count = $res->rowCount();
            $res->closeCursor();
            return $count;
        }

        try {
            $ret = $this->formatRs($res, $return_type);
        } catch (RowMissingException $ex) {
            $res->closeCursor();

            if (!static::$override_connection) {
                Fp::log($ex, 'Failed formatRs');
            }

            $ex->query = $query;
            $ex->params = $params;
            throw $ex;
        }
        $res->closeCursor();
        $res = null;
        return $ret;
    }


    /**
     * Prepare a query into a prepared statement
     * This is just a wrapper for {@see Pdb::query} with the return type of 'prep'.
     *
     * @param string $query The query to execute. Prefix a table name with a tilde (~) to automatically include the
     *        table prefix, e.g. ~pages will be converted to sprout_pages
     * @return PDOStatement The prepared statement, for execution with {@see Pdb::execute}
     * @throws QueryException If the query execution or formatting failed
     */
    public function prepare($query) {
        return $this->query($query, [], 'prep');
    }


    /**
     * Executes a prepared statement
     *
     * For the return type 'pdo', a PDOStatement is returned. You need to close it using $res->closeCursor()
     *     once you're finished.
     * For the return type 'null', nothing is returned.
     * For the return type 'count', a count of rows is returned.
     * Additional return types are available; {@see Pdb::formatRs} for a full list.
     *
     * When working with datasets larger than about 50 rows, you may run out of ram when using
     * return types other than 'pdo', 'null', 'count' or 'val' because the other types all return the values as arrays
     *
     * @param PDOStatement $st The query to execute. Prepare using {@see Pdb::query} and the return type 'prep'.
     * @param array $params Parameters to bind to the query
     * @param string $return_type 'pdo', 'prep', 'count', 'null', or a format type {@see Pdb::formatRs}
     * @return PDOStatement For type 'pdo'
     * @return int For type 'count'
     * @return null For type 'null'
     * @return mixed For all other types; see {@see Pdb::formatRs}
     * @throws InvalidArgumentException If the return type isn't valid
     * @throws QueryException If the query execution or formatting failed
     */
    public function execute(PDOStatement $st, array $params, $return_type)
    {
        static $types = [
            'pdo', 'null', 'count', 'arr', 'arr-num', 'row', 'row-num', 'map', 'map-arr', 'val', 'col'
        ];

        $return_type = strtolower($return_type);
        if (!in_array($return_type, $types)) {
            $err = 'Invalid $return_type; see documentation';
            throw new InvalidArgumentException($err);
        }

        $st->execute($params);
        $res = $st;
        $count = $res->rowCount();

        if ($return_type == 'pdo') {
            $res->setFetchMode(PDO::FETCH_ASSOC);
            return $res;
        } else if ($return_type == 'null') {
            $res->closeCursor();
            return null;
        } else if ($return_type == 'count') {
            $count = $res->rowCount();
            $res->closeCursor();
            return $count;
        }

        try {
            $ret = $this->formatRs($res, $return_type);
        } catch (RowMissingException $ex) {
            $res->closeCursor();

            if (!static::$override_connection) {
                Fp::log($ex, 'Failed formatRs');
            }

            $ex->params = $params;
            throw $ex;
        }
        $res->closeCursor();
        $res = null;
        return $ret;
    }


    /**
     * Converts a PDO result set to a common data format:
     *
     * arr      An array of rows, where each row is an associative array.
     *          Use only for very small result sets, e.g. <= 20 rows.
     *
     * arr-num  An array of rows, where each row is a numeric array.
     *          Use only for very small result sets, e.g. <= 20 rows.
     *
     * row      A single row, as an associative array
     *
     * row-num  A single row, as a numeric array
     *
     * map      An array of identifier => value pairs, where the
     *          identifier is the first column in the result set, and the
     *          value is the second
     *
     * map-arr  An array of identifier => value pairs, where the
     *          identifier is the first column in the result set, and the
     *          value an associative array of name => value pairs
     *          (if there are multiple subsequent columns)
     *
     * val      A single value (i.e. the value of the first column of the
     *          first row)
     *
     * col      All values from the first column, as a numeric array.
     *          DO NOT USE with boolean columns; see note at
     *          http://php.net/manual/en/pdostatement.fetchcolumn.php
     *
     * @param string $type One of 'arr', 'arr-num', 'row', 'row-num', 'map', 'map-arr', 'val' or 'col'
     * @return array For most types
     * @return string For 'val'
     * @throws RowMissingException If the result set didn't contain the required row
     */
    public function formatRs(PDOStatement $rs, $type)
    {
        switch ($type) {
        case 'arr':
            return $rs->fetchAll(PDO::FETCH_ASSOC);
            break;

        case 'arr-num':
            return $rs->fetchAll(PDO::FETCH_NUM);
            break;

        case 'row':
            $row = $rs->fetch(PDO::FETCH_ASSOC);
            if (!$row) throw new RowMissingException('Expected a row');
            return $row;
            break;

        case 'row-num':
            $row = $rs->fetch(PDO::FETCH_NUM);
            if (!$row) throw new RowMissingException('Expected a row');
            return $row;
            break;

        case 'map':
            if ($rs->columnCount() < 2) {
                throw new Exception('Two columns required');
            }
            $map = array();
            while ($row = $rs->fetch(PDO::FETCH_NUM)) {
                $map[$row[0]] = $row[1];
            }
            return $map;
            break;

        case 'map-arr':
            $map = array();
            while ($row = $rs->fetch(PDO::FETCH_ASSOC)) {
                $id = reset($row);
                $map[$id] = $row;
            }
            return $map;
            break;

        case 'val':
            $row = $rs->fetch(PDO::FETCH_NUM);
            if (!$row) throw new RowMissingException('Expected a row');
            return $row[0];
            break;

        case 'col':
            $arr = [];
            while (($col = $rs->fetchColumn(0)) !== false) {
                $arr[] = $col;
            }
            return $arr;
            break;

        default:
            $err = "Unknown return type: {$type}";
            throw new InvalidArgumentException($err);
        }
    }


    /**
     * Validates an identifier (column name, table name, etc)
     * @param string $name The identifier to check
     * @return void
     * @throws InvalidArgumentException If the identifier is invalid
     */
    public function validateIdentifier($name)
    {
        if (!preg_match('/^[a-z_][a-z_0-9]*$/i', $name)) {
            throw new InvalidArgumentException("Invalid identifier: {$name}");
        }
    }


    /**
     * Validates an identifier in extended format -- table.column
     * Also accepts short format like {@see validateIdentifier} does.
     *
     * @param string $name The identifier to check
     * @return void
     * @throws InvalidArgumentException If the identifier is invalid
     */
    public function validateIdentifierExtended($name)
    {
        if (!preg_match('/^(?:[a-z_][a-z_0-9]*\.)?[a-z_][a-z_0-9]*$/i', $name)) {
            throw new InvalidArgumentException("Invalid identifier: {$name}");
        }
    }


    /**
     * Runs an INSERT query
     * @param string $table The table (without prefix) to insert the data into
     * @param array $data Data to insert, column => value
     * @return int The id of the newly-inserted record, if applicable
     * @throws InvalidArgumentException
     * @throws QueryException
     */
    public function insert($table, array $data)
    {
        $this->validateIdentifier($table);
        if (count($data) == 0) {
            $err = 'An INSERT must set at least 1 column';
            throw new InvalidArgumentException($err);
        }

        $q = "INSERT INTO ~{$table}";

        $cols = '';
        $values = '';
        $insert = [];
        foreach ($data as $col => $val) {
            $this->validateIdentifier($col);
            if ($cols) $cols .= ', ';
            $cols .= $col;
            if ($values) $values .= ', ';
            $values .= ":{$col}";
            $insert[":{$col}"] = $val;
        }
        $q .= " ({$cols}) VALUES ({$values})";

        $this->q($q, $insert, 'count');
        return $this->$last_insert_id;
    }


    /**
     * Return the value from the autoincement of the most recent INSERT query
     *
     * @return int The record id
     * @return null If there hasn't been an insert yet
     */
    public function insert_id()
    {
        return $this->last_insert_id;
    }


    /**
     * Builds a clause string by combining conditions, e.g. for a WHERE or ON clause.
     * The resultant clause will contain ? markers for safe use in a prepared SQL statement.
     * The statement and the generated $values can then be run via {@see Pdb::query}.
     *
     * Each condition (see $conditions) is one of:
     *   - The scalar value 1 or 0 (to match either all or no records)
     *   - A column => value pair
     *   - An array with three elements: [column, operator, value(s)].
     *
     * Conditions are usually combined using AND, but can also be OR or XOR; see the $combine parameter.
     *
     * @param array $conditions
     * Conditions for the clause. Each condition is either:
     * - The scalar value 1 (to match ALL records -- BEWARE if using the clause in an UPDATE or DELETE)
     * - The scalar value 0 (to match no records)
     * - A column => value pair for an '=' condition.
     *   For example: 'id' => 3
     * - An array with three elements: [column, operator, value(s)]
     *   For example:
     *       ['id', '=', 3]
     *       ['date_added', 'BETWEEN', ['2010', '2015']]
     *       ['status', 'IN', ['ACTIVE', 'APPROVE']]
     *   Simple operators:
     *       =  <=  >=  <  >  !=  <>
     *   Operators for LIKE conditions; escaping of characters like % is handled automatically:
     *       CONTAINS  string
     *       BEGINS    string
     *       ENDS      string
     *   Other operators:
     *       IS        string 'NULL' or 'NOT NULL'
     *       BETWEEN   array of 2 values
     *       (NOT) IN  array of values
     *       IN SET    string -- note the order matches other operators; ['column', 'IN SET', 'val1,ca']
     * @param array $values Array of bind parameters. Additional parameters will be appended to this array
     * @param string $combine String to be placed between the conditions. Must be one of: 'AND', 'OR', 'XOR'
     * @return string A clause which is safe to use in a prepared SQL statement
     * @example
     * $conditions = ['active' => 1, ['date_added', 'BETWEEN', ['2015-01-01', '2016-01-01']]];
     * $params = [];
     * $where = Pdb::buildClause($conditions, $params);
     * //
     * // Variable contents:
     * // $where == "active = ? AND date_added BETWEEN ? AND ?"
     * // $params == [1, '2015-01-01', '2016-01-01'];
     * //
     * $q = "SELECT * FROM ~my_table WHERE {$where}";
     * $res = Pdb::query($q, $params, 'pdo');
     * foreach ($res as $row) {
     *     // Record processing here
     * }
     * $res->closeCursor();
     */
    public function buildClause(array $conditions, array &$values, $combine = 'AND')
    {
        if ($combine != 'AND' and $combine != 'OR' and $combine != 'XOR') {
            throw new InvalidArgumentException('Combine paramater must be of of: "AND", "OR", "XOR"');
        }
        $combine = " {$combine} ";

        $where = '';
        foreach ($conditions as $key => $cond) {
            if ($where) $where .= $combine;
            if (is_scalar($cond)) {
                if (preg_match('/^[0-9]+$/', $key)) {
                    $cond = (string) $cond;
                    if ($cond != '1' and $cond != '0') {
                        $err = '1 and 0 are the only accepted scalar conditions';
                        throw new InvalidArgumentException($err);
                    }
                    $where .= $cond;
                } else {
                    $this->validateIdentifierExtended($key);
                    $where .= "{$key} = ?";
                    $values[] = $cond;
                }
                continue;
            }

            if (count($cond) != 3) {
                $err = 'An array condition needs exactly 3 elements: ';
                $err .= 'column, operator, value(s)';
                throw new InvalidArgumentException($err);
            }
            list($col, $op, $val) = $cond;
            $this->validateIdentifierExtended($col);

            switch ($op) {
            case '=':
            case '<=':
            case '>=':
            case '<':
            case '>':
            case '!=':
            case '<>':
                if (!is_scalar($val)) {
                    $err = "Operator {$op} needs a scalar value";
                    throw new InvalidArgumentException($err);
                }
                $where .= "{$col} {$op} ?";
                $values[] = $val;
                break;

            case 'IS':
                if ($val == 'NULL' or $val == 'NOT NULL') {
                    $where .= "{$col} {$op} {$val}";
                } else {
                    $err = "Operator IS value must be NULL or NOT NULL";
                    throw new InvalidArgumentException($err);
                }
                break;

            case 'BETWEEN':
                $err = "Operator BETWEEN value must be an array of two scalars";
                if (!is_array($val)) {
                    throw new InvalidArgumentException($err);
                } else if (count($val) != 2 or !is_scalar($val[0]) or !is_scalar($val[1])) {
                    throw new InvalidArgumentException($err);
                }
                $where .= "{$col} BETWEEN ? AND ?";
                $values[] = $val[0];
                $values[] = $val[1];
                break;

            case 'IN':
            case 'NOT IN';
                $err = "Operator {$op} value must be an array of scalars";
                if (!is_array($val)) {
                    throw new InvalidArgumentException($err);
                } else {
                       foreach ($val as $idx => $v) {
                        if (!is_scalar($v)) {
                            throw new InvalidArgumentException($err . " (index {$idx})");
                        }
                    }
                }
                $where .= "{$col} {$op} (" . rtrim(str_repeat('?, ', count($val)), ', ') . ')';
                foreach ($val as $v) {
                    $values[] = $v;
                }
                break;

            case 'CONTAINS':
                $where .= "{$col} LIKE CONCAT('%', ?, '%')";
                $values[] = Pdb::likeEscape($val);
                break;

            case 'BEGINS':
                $where .= "{$col} LIKE CONCAT(?, '%')";
                $values[] = Pdb::likeEscape($val);
                break;

            case 'ENDS':
                $where .= "{$col} LIKE CONCAT('%', ?)";
                $values[] = Pdb::likeEscape($val);
                break;

            case 'IN SET':
                $where .= "FIND_IN_SET(?, {$col}) > 0";
                $values[] = Pdb::likeEscape($val);
                break;

            default:
                $err = 'Operator not implemented: ' . $op;
                throw new InvalidArgumentException($err);
            }
        }
        return $where;
    }


    /**
     * Runs an UPDATE query
     * @param string $table The table (without prefix) to insert the data into
     * @param array $data Data to update, column => value
     * @param array $conditions Conditions for updates. {@see Pdb::buildClause}
     * @return int The number of affected rows
     * @throws InvalidArgumentException
     * @throws QueryException
     */
    public function update($table, array $data, array $conditions)
    {
        $this->validateIdentifier($table);
        if (count($data) == 0) {
            $err = 'An UPDATE must apply to at least 1 column';
            throw new InvalidArgumentException($err);
        }
        if (count($conditions) == 0) {
            $err = 'An UPDATE requires at least 1 condition';
            throw new InvalidArgumentException($err);
        }

        $q = "UPDATE ~{$table} SET ";

        $cols = '';
        $values = [];
        foreach ($data as $col => $val) {
            $this->validateIdentifier($col);
            if ($cols) $cols .= ', ';
            $cols .= "{$col} = ?";
            $values[] = $val;
        }
        $q .= $cols;

        $q .= " WHERE " . $this->buildClause($conditions, $values);

        return $this->q($q, $values, 'count');
    }


    /**
     * Runs a DELETE query
     * @param string $table The table (without prefix) to insert the data into
     * @param array $conditions Conditions for updates. {@see Pdb::buildClause}
     * @return int The number of affected rows
     * @throws InvalidArgumentException
     * @throws QueryException
     */
    public function delete($table, array $conditions)
    {
        $this->validateIdentifier($table);
        if (count($conditions) == 0) {
            $err = 'A DELETE requires at least 1 condition';
            throw new InvalidArgumentException($err);
        }

        $values = [];
        $q = "DELETE FROM ~{$table} WHERE " . $this->buildClause($conditions, $values);
        return $this->q($q, $values, 'count');
    }


    /**
     * Checks if there's a current transaction in progress
     * @return bool True if inside a transaction
     */
    public function inTransaction()
    {
        return $this->$in_transaction;
    }


    /**
     * Starts a transaction
     * @return void
     * @throws TransactionRecursionException if already in a transaction
     */
    public function start_transaction()
    {
        if ($this->$in_transaction) {
            throw new TransactionRecursionException();
        }

        $this->pdo->beginTransaction();
        $this->in_transaction = true;
    }


    /**
     * Commits a transaction
     * @return void
     */
    public function commit_transaction()
    {
        $this->pdo->commit();
        $this->in_transaction = false;
    }


    /**
     * Rolls a transaction back
     * @return void
     */
    public function rollback_transaction()
    {
        $this->pdo->rollBack();
        $this->in_transaction = false;
    }


    /**
     * Gets a datetime value for the current time.
     * This is used to implement MySQL's NOW() function in PHP, but may change
     * if the decision is made to use INT columns instead of DATETIMEs. This
     * will probably happen at some point, so this function should only be used
     * for generating values right before an INSERT or UPDATE query is run
     * @return string
     */
    public function now()
    {
        return date('Y-m-d H:i:s');
    }


    /**
     * Escapes the special characters % and _ for use in a LIKE clause
     * @param string $str
     * @return string
     */
    public function likeEscape($str)
    {
        return str_replace(['_', '%'], ['\\_', '\\%'], $str);
    }


    /**
     * Fetches a mapping of id => value values from a table, using the 'name' values by default
     *
     * @param string $table The table name, without prefix
     * @param array $conditions Optional where clause {@see Pdb::buildClause}
     * @param array $order Optional columns to ORDER BY. Defaults to 'name'
     * @param string $name The field to use for the mapped values
     * @return array A lookup table
     **/
    public function lookup($table, array $conditions = [], array $order = ['name'], $name = 'name')
    {
        $this->validateIdentifier($table);
        foreach ($order as $ord) {
            $this->validateIdentifier($ord);
        }
        $this->validateIdentifier($name);

        $values = [];
        $q = "SELECT id, {$name} FROM ~{$table}";
        if (count($conditions)) $q .= "\nWHERE " . $this->buildClause($conditions, $values);
        if (count($order)) $q .= "\nORDER BY " . implode(', ', $order);
        return $this->q($q, $values, 'map');
    }


    /**
     * Return all columns for a single row of a table.
     * The row is specified using its id.
     *
     * @param string $table The table name, not prefixed
     * @param int $id The id of the record to fetch
     * @return array The record data
     * @throws QueryException If the query fails
     * @throws RowMissingException If there's no row
     */
    public function get($table, $id)
    {
        $q = "SELECT * FROM ~{$table} WHERE id = ?";
        return Pdb::q($q, [(int) $id], 'row');
    }


    /**
     * Returns definition list from column of type ENUM
     * @param string $table The DB table name, without prefix
     * @param string $column The column name
     * @return array
     */
    public function extractEnumArr($table, $column)
    {
        Pdb::validateIdentifier($table);
        Pdb::validateIdentifier($column);

        $q = "SHOW COLUMNS FROM ~{$table} LIKE ?";
        $res = Pdb::q($q, [$column], 'row');

        $arr = $this->convertEnumArr($res['Type']);
        return array_combine($arr, $arr);
    }


    /**
     * Convert an ENUM or SET definition from MySQL into an array of values
     *
     * @param string $enum_defn The definition from MySQL, e.g. ENUM('aa','bb','cc')
     * @return array Numerically indexed
     */
    public function convertEnumArr($enum_defn)
    {
        $pattern = '/^(?:ENUM|SET)\s*\(\s*\'/i';
        if (!preg_match($pattern, $enum_defn)) {
            throw new InvalidArgumentException("Definition is not an ENUM or SET");
        }

        // Remove enclosing ENUM('...') or SET('...')
        $enum_defn = preg_replace($pattern, '', $enum_defn);
        $enum_defn = preg_replace('/\'\s*\)\s*$/', '', $enum_defn);

        // SQL escapes ' characters with ''
        // So split on all ',' which aren't followed by a ' character
        $vals = preg_split("/','(?!')/", $enum_defn);

        // Then convert any '' characters back into ' characters
        foreach ($vals as &$v) {
            $v = str_replace("''", "'", $v);
        }

        return $vals;
    }


    /**
     * Validates a value meant for an ENUM field, e.g.
     * $valid->addRules('col1', 'required', 'Pdb::validateEnum[table, col]');
     * @param string $val The value to find in the ENUM
     * @param array $field [0] Table name [1] Column name
     * @return bool
     */
    public function validateEnum($val, $field)
    {
        list($table, $col) = $field;
        $enum = $this->extractEnumArr($table, $col);
        if (count($enum) == 0) return false;
        if (in_array($val, $enum)) return true;
        return false;
    }


    /**
     * Gets all of the dependent foreign key columns (i.e. with the CASCADE delete rule) in other tables
     * which link to the id column of a specific table
     * @param string $table The table which contains the id column which the foreign key columns link to
     * @return array Each element is an array: ['table' => table_name, 'column' => column_name]
     */
    public function getDependentKeys($table)
    {
        $params = [Kohana::config('database.default.connection.database')];
        $params[] = self::$prefix . $table;

        $q = "SELECT K.TABLE_NAME, K.COLUMN_NAME
            FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K
            INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS C
                ON K.CONSTRAINT_NAME = C.CONSTRAINT_NAME
                AND K.TABLE_SCHEMA = C.CONSTRAINT_SCHEMA
                AND C.DELETE_RULE = 'CASCADE'
            WHERE K.TABLE_SCHEMA = ?
                AND K.CONSTRAINT_NAME != ''
                AND K.REFERENCED_TABLE_NAME = ?
                AND K.REFERENCED_COLUMN_NAME = 'id'
            ORDER BY K.TABLE_NAME, K.COLUMN_NAME";
        $res = self::query($q, $params, 'pdo');

        $rows = [];
        $pattern = '/^' . preg_quote(self::$prefix, '/') . '/';
        while ($row = $res->fetch(PDO::FETCH_NUM)) {
            $rows[] = [
                'table' => preg_replace($pattern, '', $row[0]),
                'column' => $row[1]
            ];
        }
        $res->closeCursor();
        return $rows;
    }


    /**
     * @deprecated
     */
    function sql_safen($input)
    {
        return $this->pdo->quote($input);
    }


    /**
     * @deprecated
     */
    function fetch_row($res)
    {
        $row = $res->fetch(PDO::FETCH_NUM);
        if ($row) return $row;

        if (in_array($res, $this->exhausted, true)) {
            throw new Exception("Attempt to reuse PDO result");
        }
        $this->exhausted[] = $res;
        return false;
    }


    /**
     * @deprecated
     */
    function fetch_assoc($res)
    {
        $row = $res->fetch(PDO::FETCH_ASSOC);
        if ($row) return $row;

        if (in_array($res, $this->exhausted, true)) {
            throw new Exception("Attempt to reuse PDO result");
        }
        $this->exhausted[] = $res;
        return false;
    }


    /**
     * @deprecated
     */
    function affected_rows($res)
    {
        return $res->rowCount();
    }


    /**
     * @todo This is MySQL-only atm.
     *       Make this an abstract function and implement it in each different db type,
     *       or do it using INFORMATION_SCHEMA if it works for mysql, postgres and sqlite
     */
    function get_table_list()
    {
        return $this->query('SHOW TABLES', [], 'col');
    }


    /**
     * @param string $table_name
     * @todo This is MySQL-only atm.
     *       Make this an abstract function and implement it in each different db type,
     *       or do it using INFORMATION_SCHEMA if it works for mysql, postgres and sqlite
     */
    function get_column_details($table_name)
    {
        $this->validateIdentifier($table_name);
        $q = 'SHOW COLUMNS IN ' . $table_name;
        $res = $this->query($q, [], 'pdo');

        $columns = [];
        foreach ($res as $row) {
            if ($row['Null'] == 'YES') {
                $row['NotNull'] = false;
            } else {
                $row['NotNull'] = true;
            }

            // Remap the SQL types back to Pelzini type
            $row['Type'] = preg_replace('/\(.+\)/', '', $row['Type']);
            $row['Type'] = strtolower($row['Type']);
            switch ($row['Type']) {
            case 'smallint unsigned': $row['Type'] = 'smallnum'; break;
            case 'smallint': $row['Type'] = 'smallnum'; break;
            case 'bigint unsigned':
                $row['Type'] = 'largenum';
                if ($row['NotNull'] and stripos('auto_increment', $row['Extra']) !== false) {
                    $row['Type'] = 'serial';
                }
                break;
            case 'bigint': $row['Type'] = 'largenum'; break;
            case 'int unsigned': $row['Type'] = 'largenum'; break;
            case 'int': $row['Type'] = 'largenum'; break;
            case 'varchar': $row['Type'] = 'string'; break;
            case 'mediumtext': $row['Type'] = 'text'; break;
            }

            unset($row['Extra'], $row['Default']);
            $columns[] = $row;
        }
        $res->closeCursor();

        return $columns;
    }


    /**
     * @param string $table_name
     * @todo This is MySQL-only atm.
     *       Make this an abstract function and implement it in each different db type,
     *       or do it using INFORMATION_SCHEMA if it works for mysql, postgres and sqlite
     */
    function get_index_details($table_name)
    {
        $this->validateIdentifier($table_name);
        $q = 'SHOW INDEXES IN ' . $table_name;
        $res = $this->query($q, [], 'pdo');

        $indexes = [];
        foreach ($res as $row) {
            if (!isset($indexes[$row['Key_name']])) {
                $indexes[$row['Key_name']] = ['Fields' => []];
            }

            $indexes[$row['Key_name']]['Fields'][] = $row['Column_name'];
        }
        $res->closeCursor();

        return $indexes;
    }


    /**
     * @todo This is MySQL-only atm.
     *       Make this an abstract function and implement it in each different db type,
     *       or do it using INFORMATION_SCHEMA if it works for mysql, postgres and sqlite
     * @todo do something with the $not_null param, srsly
     */
    function get_alter_column_query($table, $column_name, $new_type, $not_null)
    {
        $new_type = $this->get_sql_type($new_type);

        $q = "ALTER TABLE {$table} MODIFY COLUMN {$column_name} {$new_type}";
        return $q;
    }


    /**
     * @todo This is MySQL-only atm.
     *       Make this an abstract function and implement it in each different db type,
     *       or do it using INFORMATION_SCHEMA if it works for mysql, postgres and sqlite
     */
    function get_sql_type($internal_type_name)
    {
        switch ($internal_type_name) {
        case 'serial': return 'SERIAL';
        case 'smallnum': return 'SMALLINT UNSIGNED';
        case 'largenum': return 'BIGINT UNSIGNED';
        case 'string': return 'VARCHAR(255)';
        case 'text': return 'MEDIUMTEXT';
        default:
            throw new Exception ("Undefined type '{$internal_type_name}' specified");
            break;
        }
    }


    /**
     * @param string $table_name Name of table to create
     * @param array $dest_table Definition including columns and indexes.
     *        This is probably documented somewhere...
     * @todo This is MySQL-only atm.
     *       Make this an abstract function and implement it in each different db type,
     *       or do it using INFORMATION_SCHEMA if it works for mysql, postgres and sqlite
     */
    function create_table($table_name, array $dest_table)
    {
        $q = "CREATE TABLE {$table_name} (\n";
        foreach ($dest_table['Columns'] as $col_name => $col_def) {
            $dest_sql = $this->get_sql_type($col_def['Type']);
            if ($col_def['NotNull']) $dest_sql .= ' not null';

            $q .= "  {$col_name} {$dest_sql},\n";
        }
        foreach ($dest_table['Indexes'] as $col_name) {
            $q .= "  INDEX ({$col_name}),\n";
        }
        $q .= "  PRIMARY KEY ({$dest_table['PK']})\n";
        $q .= ") ENGINE=MyISAM";
        echo "<b>Query:\n{$q}</b>\n";

        $res = $this->query($q);
        if ($res) echo 'Affected rows: ', $this->affected_rows($res), "\n";
    }

}


class TransactionRecursionException
{
}
